# Методы принятия решений

Этот файл содержит описание и результаты всех проделанных нами работ. Работы
подготовили:
_Орлова Татьяна и Юлия Ивлева, 401-И_

## Навигация

- [Метрические алгоритмы классификации](#Метрические-алгоритмы-классификации)
  - [K ближайших соседей (KNN)](#k-ближайших-соседей-knn)
  - [K взвешанных ближайших соседей (KNN)](#k-взвешанных-ближайших-соседей-knn)
  - [Парзеновское окно (PW)](#Парзеновское-окно-pw)
  - [Потенциальные функции (PF)](#Потенциальные-функции-pf)

## Метрические алгоритмы классификации

Метрические алгоритмы классификации основаны на __гипотезе компактности__,
которая говорит о том, что <u>схожим объектам соответствуют схожие ответы</u>.

Функцию, определяющую "схожесть" объектов называют __мерой близости__.
Эта функция определяется следующим образом:

![](http://latex.codecogs.com/svg.latex?%5Clarge%20%5Crho%3A%20%28X%20%5Ctimes%20X%29%20%5Crightarrow%20%5Cmathbb%7BR%7D)
(функция расстояния)

Все дальнейшие методы будут основаны на анализе сходства объектов.

### K ближайших соседей (KNN)

Для оценки близости объекта _u_ к классу _y_ алгоритм использует следующую
функцию:
![](http://latex.codecogs.com/svg.latex?%5Clarge%20W%28i%2C%20u%29%20%3D%20%5Bi%20%5Cleq%20k%5D)
, где _i_ обозначает порядок соседа по расстоянию к точке _u_.

Другими словами, алгоритм выбирает _k_ ближайших соседей и возвращает
тот класс, который среди выбранных встречается большее количество раз.

Реализация алгоритма доступна по
[ссылке](oRRRlova/KNN.R)

#### Оценка алгоритма

Протестируем алгоритм на выборке ирисов Фишера:

![LOO для KNN...](IMG/KNN.png)

Алгоритм хорошо себя показывает при небольшом _k_, допуская ошибку лишь в
нескольких объектах, однако при росте _k_, начиная с _k > 95_, ошибка
стремительно растет. Это объясняется тем, что функция оценки близости
![](http://latex.codecogs.com/svg.latex?%5Clarge%20W%28i%2C%20u%29%20%3D%20%5Bi%20%5Cleq%20k%5D)
никак не учитывает порядок элементов, а учитывает лишь их наличие. Из-за
этого те объекты, что находятся очень далеко от точки _u_ влияют на
классификацию с такой же силой, что и объекты, находящиеся в
непосредственной близости.

__Плюсы:__
- прост в реализации
- неплохие результаты при правильно подобраном _k_

__Минусы:__
- необходимо хранить всю выборку целиком
- классификация точки занимает
![](http://latex.codecogs.com/svg.latex?%5Clarge%20O%28n%20%5Clog%20n%29)
, так как требует сортировку точек по расстоянию
- бедный набор параметров
- примитивная оценка близости
- в случае одинаковых весов классов алгоритм выбирает любой
- не все точки с одинаковым расстоянием будут учитаны

### K взвешенных ближайших соседей (KNN)

Для оценки близости объекта _u_ к классу _y_ алгоритм использует следующую
функцию:
![](http://latex.codecogs.com/svg.latex?%5Clarge%20W%28i%2C%20u%29%20%3D%20%5Bi%20%5Cleq%20k%5D%20w%28i%29)
, где _i_ обозначает порядок соседа по расстоянию к точке _u_, а 
![](http://latex.codecogs.com/svg.latex?%5Clarge%20w%28i%29) — строго
убывающая функция веса. Последней алгоритм __взвешенного KNN__ отличается
от __KNN__.

Мы же будем применять следующую функцию веса:
![](http://latex.codecogs.com/svg.latex?%5Clarge%20w%28i%29%20%3D%20%5Cfrac%7Bk%20&plus;%201%20-%20i%7D%7Bk%7D)

Реализация алгоритма доступна по
[ссылке](oRRRlova/kwKNN.R)

#### Оценка алгоритма

Протестируем алгоритм на выборке ирисов Фишера:

![LOO для взвешанного KNN...](IMG/kwKNN.png)

Алгоритм хорошо себя показывает при любом _k_, отклонение максимальной ошибки
к минимальной всего лишь в двух объектах.

Алгоритм __взвешенных k соседей__ качественно отличается от обычного
__KNN__ тем, что <u>учитывает порядок объектов</u> при классификации. Тем
самым, ближние к точке _u_ объекты будут влиять на нее гораздо сильнее, чем
дальние. Однако из-за этой особенности, при большом _k_ дальние точки
быстро обесцениваются, поэтому функцию
![](http://latex.codecogs.com/svg.latex?%5Clarge%20w%28i%29)
следует выбирать осторожно.

__Плюсы:__
- прост в реализации
- неплохие результаты при любом _k_

__Минусы:__
- необходимо хранить всю выборку целиком
- классификация точки занимает
![](http://latex.codecogs.com/svg.latex?%5Clarge%20O%28n%20%5Clog%20n%29)
, так как требует сортировку точек по расстоянию
- бедный набор параметров
- в случае одинаковых весов классов алгоритм выбирает любой
(однако стоит заметить, что эти случаи будут встречаться крайне редко)
- не все точки с одинаковым расстоянием будут учитаны

### Парзеновское окно (PW)

Для оценки близости объекта _u_ к классу _y_ алгоритм использует следующую
функцию:

![](http://latex.codecogs.com/svg.latex?%5Clarge%20W%28i%2C%20u%29%20%3D%20K%28%5Cfrac%7B%5Crho%28u%2C%20x%5Ei_u%29%7D%7Bh%7D%29)
, где 
![](http://latex.codecogs.com/svg.latex?%5Clarge%20K%28z%29) — функция ядра.

Чаще всего применяются 4 типа ядер:
- Прямоугольное ![](http://latex.codecogs.com/svg.latex?%5Clarge%20R%28z%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5B%7Cz%7C%20%5Cleq%201%5D)
- Треугольное ![](http://latex.codecogs.com/svg.latex?%5Clarge%20T%28z%29%20%3D%20%281%20-%20%7Cz%7C%29%20%5Ccdot%20%5B%7Cz%7C%20%5Cleq%201%5D)
- Квартическое ![](http://latex.codecogs.com/svg.latex?%5Clarge%20Q%28z%29%20%3D%20%5Cfrac%7B15%7D%7B16%7D%20%281%20-%20z%5E2%29%5E2%20%5Ccdot%20%5B%7Cz%7C%20%5Cleq%201%5D)
- Епанечниково ![](http://latex.codecogs.com/svg.latex?%5Clarge%20E%28z%29%20%3D%20%5Cfrac%7B3%7D%7B4%7D%20%281%20-%20z%5E2%29%20%5Ccdot%20%5B%7Cz%7C%20%5Cleq%201%5D)

Мы в программе будем применять ядра поочередно, однако на качество классификации они
влияют слабо.

__Простыми словами:__ алгоритм для классифицируемой точки _u_ строит
окружность, радиусом _h_. Все точки, не попавшие в эту окружность,
отсеиваются (хотя это зависит от ядра). Для остальных, вычисляется вес,
суммируется, и класс с наибольшим весом считается победителем.

Реализация алгоритма доступна по
[ссылке](oRRRlova/PW.R)

#### Оценка алгоритма

Протестируем алгоритм на выборке ирисов Фишера:

_Прямоугольное ядро:_
![LOO для PW...](IMG/PW_R.png)

_Треугольное ядро:_
![LOO для PW...](IMG/PW_T.png)

_Квартическое ядро:_
![LOO для PW...](IMG/PW_Q.png)

_Епанечково ядро:_
![LOO для PW...](IMG/PW_E.png)

Алгоритм хорошо себя показывает при _h_ лишь в небольшом диапазоне.
Этот диапазон зависит от плотности классифицируемых точек. Если _h_ сделать
слишком маленьким, количество "белого" простарнства на карте классификации
заметно возрастет. Если _h_ сделать слишком большим, он начнет учитывать при
классификации слишком дальние точки. Однако стоит отметить, что в некоторых ядрах
веса дальних точек гораздо меньше, и качество алгоритма при больших _h_ падает не так
сильно. Неудачным ядром (по нашему мнению) является _прямоугольное_, так как веса
всех точек внутри окна одинаковые.

Алгоритм Парзеновского окна прост в понимании и реализации (даже проще, чем
__KNN__). Он имеет достаточно маленькую ошибку в определенном промежутке,
 однако имеет ряд существенных недостатков, которыми __KNN__ и __взвешанный
KNN__ не обладают.

__Плюсы:__
- прост в реализации
- неплохие результаты при правильно подобраном _h_
- все точки с одинаковым расстоянием будут учитаны
- классификация точки занимает
![](http://latex.codecogs.com/svg.latex?%5Clarge%20O%28n%29)
, так как не требует сортировки

__Минусы:__
- необходимо хранить всю выборку целиком
- бедный набор параметров
- в случае одинаковых весов классов алгоритм выбирает любой
(однако стоит заметить, что эти случаи будут встречаться редко)
- диапазон параметра _h_ необходимо подбирать самостоятельно, учитывая
плотность расположения точек
- если ни одна точка не попала в радиус _h_, алгоритм не способен ее
классифицировать (см. рисунок)! На наш взгляд, это самый существенный
недостаток

### Потенциальные функции (PF)

Для оценки близости объекта _u_ к классу _y_ алгоритм использует следующую
функцию:

![](http://latex.codecogs.com/svg.latex?W_y%28i%2C%20u%29%20%3D%20%5Cgamma_i%20%5Ccdot%20K%28%5Cfrac%7B%5Crho%28u%2C%20x_u%5Ei%29%7D%7Bh_i%7D%29%2C%20%5Cgamma_i%20%5Cgeq%200%2C%20h_i%20%3E%200)
, где 
![](http://latex.codecogs.com/svg.latex?%5Clarge%20K%28z%29) — функция ядра.

Мы в программе будем применять квартическое ядро (для разнообразия).
Алгоритм подбирает только силу потенциала
![](http://latex.codecogs.com/svg.latex?%5Cgamma_i), радиусы потенциалов
_h_ известны заранее.

__Простыми словами:__ алгоритм для каждого обучающего объекта _x_ строит
окружность, радиуса _h_ и силы воздействия (потенциала)
![](http://latex.codecogs.com/svg.latex?%5Cgamma_i).

Реализация алгоритма доступна по
[ссылке](oRRRlova/PF.R)

#### Оценка алгоритма

Протестируем алгоритм на выборке ирисов Фишера. Так как своей целью мы
ставим лишь подбор
![](http://latex.codecogs.com/svg.latex?%5Cgamma_i), а не _h_, то
выбирем их любым образом (пускай для красных точек _h = 1_, так как они
отделены от остальной обучающей выборки; остальным присвоим _h = 0.25_).

Алгоритм подобрал оптимальные параметры (4 ошибки) за 16 проходов:

![Потенциалы PF...](IMG/PF.png)

Алгоритм заметно сложнее в понимании и реализации, чем предшествующие
алгоритмы. К тому же подбор силы потенциалов занимает долгое время. К
сожалению, это время оценить невозможно, так как алгоритм является
случайным (следующий _x_ в итерации берется случайным образом). При
запуске алгоритма на одной и той же выборке, он показывает разное время
работы (а также разное количество итераций).

__Плюсы:__
- результат зависит от _2n_ параметров
- очень сложно найти в нем еще что-нибудь хорошее :)

__Минусы:__
- необходимо хранить всю выборку целиком
- параметры _h_ необходимо подбирать самостоятельно
- если ни одна точка не попала в радиус _h_, алгоритм не способен ее
классифицировать
- медленно сходится
- слишком грубо настраивает параметры
- неопределенное время работы (при маленьком пороге ошибки может вообще
выполняться бесконечно)